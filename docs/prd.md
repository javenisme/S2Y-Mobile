# 反推需求 PRD（基于代码与文档）

## 背景与问题陈述
- **问题**: 数字健康应用在跨模块协同、数据流、SwiftUI 集成与可测试性方面易出现高耦合与脆弱生命周期管理。
- **机会**: 通过标准化模块契约与装载/注入机制，降低集成复杂度并提升扩展性与复用性。

## 产品愿景与目标
- **愿景**: 提供一套面向数字健康的模块化 Swift 框架，支持快速、安全、可组合的功能构建。
- **目标**:
  - 标准化模块接口与生命周期（`Module`, `Standard`）
  - 解耦模块间数据交换（`@Provide`/`@Collect`）与依赖（`@Dependency`）
  - 将框架能力与 SwiftUI 深度整合（环境注入、视图修饰、AppDelegate 适配）
  - 支持动态装载/卸载模块与服务运行
  - 保障运行时正确性并提供明确的误用反馈

## 非目标
- 并不提供具体业务模块（如问卷、蓝牙、账户等），而是提供支撑基础；具体模块在其他 Spezi 子仓库中实现。
- 不覆盖非 Apple 平台或早期系统版本（最低 iOS 17 / macOS 14 等）。

## 角色与场景
- **应用开发者**: 以 SwiftUI 应用集成为主，按需选择模块并组合。
- **模块作者**: 基于 `Module`/`Standard` 与能力系统，编写可复用模块。
- **QA/测试工程师**: 通过 `SpeziTesting`/`XCTSpezi` 与可观测性对模块进行验证。

## 核心需求（功能性）
1. 模块生命周期管理
   - 框架能装载、初始化、配置并运行模块；支持外部与框架托管两种所有权策略
   - 支持动态装载/卸载，确保依赖有序、安全
2. 依赖声明与解析
   - 支持必选/可选/默认/集合依赖，解析错误可定位并阻止运行
3. 数据通道
   - 通过 `@Provide` 与 `@Collect` 完成跨模块数据分发与聚合，解耦依赖关系
4. 应用上下文访问
   - 通过 `@Application` 可访问 `logger`、`spezi`、`launchOptions`、通知注册接口等
5. SwiftUI 集成
   - 自动环境注入与 ViewModifier 汇总管理，保证渲染顺序与依赖访问语义
6. 服务与运行
   - 提供 `run()` 驱动服务模块生命周期，支持取消与清理

## 非功能性需求
- **可维护性**: 模块职责清晰、能力边界明确、文档全面（DocC 与 README）
- **健壮性**: 通过运行时断言与错误类型阻止误用（时机、线程、依赖）
- **扩展性**: 容易新增能力包装器、标准协议或依赖构建器
- **性能**: 装卸载与依赖解析为线性可扩展；避免不必要的全局重渲染
- **可测试性**: 提供 `SpeziTesting`/`XCTSpezi` 以支持单元与集成测试

## 关键设计
- `Spezi` 作为单一运行时聚合器：模块管理、数据存储、视图修饰与通知
- `Provide/Collect` 分离数据与依赖维度，减少强耦合
- `DependencyManager` 统一解析与注入路径，支持隐式创建和递归卸载
- 以 `Actor` 方式定义 `Standard`，明确并发语义

## 成功度量
- 新增模块集成时间（理想：< 1 天）
- 运行时错误率（装载/依赖相关）显著下降
- 模块间代码复用率提升
- 应用启动时间与首屏渲染无显著退化

## 发布与兼容性
- 最低支持版本：iOS 17 / macOS 14 / tvOS 17 / watchOS 10 / visionOS 1
- 通过 Swift Package Manager 集成；SwiftLint 可选

## 开放问题与后续迭代
- `@Collect` 访问窗口限定在 `configure()`：是否需要拓展为可订阅流模型？
- 动态装卸载对 SwiftUI 大规模重渲染的影响优化策略
- 更多系统能力包装器（后台任务、HealthKit、App Intents）的一致化注入